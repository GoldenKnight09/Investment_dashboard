# -*- coding: utf-8 -*-
"""
Created on Fri Dec 27 22:51:51 2024

@author: chris
"""

import pandas as pd
from datetime import date, timedelta, datetime
from re import compile
# import dash_bootstrap_components as dbc
import yfinance as yf
import plotly.graph_objects as go

# def generate_dropdown_menu_item(dropdown_item):
#     '''
#     Function to create dropdown menu items inside the function to create the dropdowns
#     (Used to avoid: TypeError: Object of type generator is not JSON serializable)
    
#     Inputs:
#         dropdown_item: string to be converted into a dash bootstrap component DropdownMenuItem
#     Outputs:
#         dash bootstrap commponet DropdownMenuItem
#     '''
#     return dbc.DropdownMenuItem(children=dropdown_item,
#                                 id = f'dropdown_item_{dropdown_item}')
# def generate_dropdown_menu(dropdown_df,tab_prefix,group_name):
#     '''
#     Function to generate dropdown menus
    
#     Inputs:
#         dropdown_df: a dataframe with the dropdown menu items as the index
#         tab_prefix: string used as part of the component id
#         group_name: string tag included in the text displayed in the dropdown menu prompt as well as the element id
#     Outputs:
#         dash boostrap component DropdownMenu with DropdownMenuItem entries generated by the generate_dropdown_menu_item function
#     '''
#     return dbc.DropdownMenu(label = f'Select a {group_name} stock...',
#                             id = f'{tab_prefix}_dropdown_{group_name}',
#                             children = [generate_dropdown_menu_item(dropdown_item) for dropdown_item in dropdown_df.index.to_list()])

def non_day_timedelta(increment_type,increment_amount):
    '''
    Function used to convert string inputs into a date output
    
    Inputs:
        increment_type: string indicating the type of increment to be used to determine the date
        increment_amount: number indicating the amount of the increment to be used
    Returns: a datetime object (starting date for slicing equity data)
    '''
    today_year = date.today().year
    today_month = date.today().month
    today_day = date.today().day
    if increment_type == 'y':
        new_year = today_year - increment_amount
    else:
        new_year = today_year
    if increment_type == 'm':
        new_month = today_month - increment_amount
        # add logic in case the start date is in the previous year
        if new_month <= 0:
            new_month = new_month + 12
            new_year = today_year - 1
    else:
        new_month = today_month
    if increment_type == 'ytd':
        if (today_month == 1) and (today_day == 1):
            new_day = today_day
        else:
            new_month, new_day = 1,1
    else:
        new_day = today_day
    return datetime.strptime(str(new_year)+str(new_month)+str(new_day),'%Y%m%d').date()

def start_date(radio_date_input):
    '''
    Match-case function to parse date radioitem output from UI
    
    Inputs:
        radio_date_input: output from radioitem selectors from UI
    Returns: a matched datetime object (starting date for slicing equity data)
    '''
    match radio_date_input:
        case '7d':
            return date.today() - timedelta(days = 7)
        case '14d':
            return date.today() - timedelta(days = 14)
        case '1m':
            return non_day_timedelta('m', 1)
        case '3m':
            return non_day_timedelta('m', 3)
        case '6m':
            return non_day_timedelta('m', 6)
        case '1y':
            return non_day_timedelta('y', 1)
        case 'ytd':
            return non_day_timedelta('ytd', 0)
        # case max is the full ticker dataframe, no need to filter, use guard if statement to block this function
        # case custom is not valid for this function, use guard if statement to block this function
        case _: # catch
            return date.today - timedelta(days = 3)
        
def stock_chart_y_label(ticker_symbol):
    # Set stock price chart y-axis (currency) label
    if '.' in ticker_symbol:
        ticker_split = compile(r'.*\.(\D{1,2})')
        match ticker_split.split(ticker_symbol)[1]:
            case 'DE' | 'PA':
                return 'Price (€)'
            case 'L':
                return 'Price (£)'
            case 'SW':
                return 'Price (CHF)'
            case 'T' | 'SS':
                return 'Price (¥)'
            case 'HK':
                return 'Price (HK$)'
    else:
        return 'Price ($)'

def index_chart_y_label(ticker_symbol):
    # Set index price chart y-axis (currency) label
    match ticker_symbol:
        case '^GDAXI':
            return 'Price (€)'
        case '^FTSE':
            return 'Price (£)'
        case '^N225' | '000001.SS' | '000300.SS':
            return 'Price (¥)'
        case '^HSI':
            return 'Price (HK$)'
        case _:
            return 'Price ($)'

def equity_plot_y_label(ticker_symbol,equity_type):
    # select the function to use to determine equity plot y-axis label
    match equity_type:
        case 'Index':
            return index_chart_y_label(ticker_symbol)
        case 'Stock':
            return stock_chart_y_label(ticker_symbol)

def generate_plotly_plot(ticker_symbol,date_select,equity_type,look_up_table,custom_start_date = None,custom_end_date = None):
    '''
    Function for generating a plot for equities
    
    Inputs:
        ticker_symbol: string corresponding to the ticker symbol of the equity
        date_select: string corresponding to the output from the radioitem selction
        equity_type: string correponding to the type of equity (Stock, Index, Commodity)
        look_up_table: dataframe using ticker symbols as index with full equity name as data
        custom_start_date: datetime object from daterange picker for starting slice date when custum date range is selected
        custom_end_date: datetime object from daterange picker for ending slice date when custum date range is selected
    Returns:
        Plotly graph object: candlestick plot
    '''
    eq_data = yf.Ticker(ticker_symbol).history(period = 'max')
    # history periods: ['1d', '5d', '1mo', '3mo', '6mo', '1y', '2y', '5y', '10y', 'ytd', 'max']
    # can use yf.download() for more open-ended requests, or just take max period and then filter (fewer requests)
    # index is datetime stamp, only need dates for simple manipulations
    eq_data_by_date = eq_data.copy()
    eq_data_by_date['date'] = pd.to_datetime(eq_data.index.date)
    eq_data_by_date = eq_data_by_date.set_index('date')
    if date_select != 'custom':
        if date_select == 'max':
            eq_start_date = datetime.strptime('19010101','%Y%m%d').date()
        else:
            eq_start_date = start_date(date_select)
        eq_end_date = date.today()
    else:
        eq_start_date = custom_start_date
        eq_end_date = custom_end_date
    eq_data_slice = eq_data_by_date.copy()
    eq_data_slice = eq_data_by_date.loc[(eq_data_by_date.index >= pd.to_datetime(eq_start_date)) &
                                        (eq_data_by_date.index <= pd.to_datetime(eq_end_date)),:]
    # London stock exchange stocks reported in pence, convert to pounds
    if '.L' in ticker_symbol:
        eq_data_slice.loc[:,['Open','High','Low','Close']] = eq_data_slice[['Open','High','Low','Close']] / 100
    fig = go.Figure(data = [go.Candlestick(x = eq_data_slice.index,
                                           open = eq_data_slice['Open'],
                                           high = eq_data_slice['High'],
                                           low = eq_data_slice['Low'],
                                           close = eq_data_slice['Close'],
                                           increasing_line_color = 'darkseagreen',
                                           decreasing_line_color = 'red')])
    fig.update_layout(title = f'<b>{look_up_table.loc[ticker_symbol,equity_type]}</b>',
                      title_font_size = 20,
                      title_x = 0.5,
                      xaxis_title = '<b>Date</b>',
                      yaxis_title = f'<b>{equity_plot_y_label(ticker_symbol, equity_type)}</b>',
                      xaxis_rangeslider_visible=False,
                      # showlegend = False,
                      plot_bgcolor = 'white')
    fig.update_xaxes(title_font_size = 15,
                     tickfont_size = 12,
                     showline = True, # plot area border line
                     linecolor = 'black', # plot area border line color
                     # mirror = True,
                     gridcolor = 'lightgray')
    fig.update_yaxes(title_font_size = 15,
                     tickfont_size = 12,
                     showline = True, # plot area border line
                     linecolor = 'black', # plot area border line color
                     # mirror = True,
                     gridcolor = 'lightgray')
    if max(eq_data_slice['High'] > 10000):
        fig.update_yaxes(tickformat = '000')
    return fig

def get_treasury_data():
    '''
    Placeholder function for get request for treasury data via API
    '''
    pass

def sup_func_main():
    pass

if __name__ == '__main__':
    sup_func_main()